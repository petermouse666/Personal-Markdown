## 汇编语言——8086指令系统中常见的/应重点掌握的指令

在《汇编语言程序设计（第五版）》（钱晓捷主编）一书中，建议读者应重点掌握常用的指令如下：

**MOV、XCHG、PUSH、POP、LEA**

**ADD、ADC、INC,SUB、SBB、DEC、NEG、CMP,MUL、IMUL、DIV、IDIV**

**AND、OR、XOR、NOT、TEST,SHL/SAL、SHR、SAR、ROL、ROR、RCL、RCR**

**JMP、JCC、LOOP、CALL、RET、INT**

本文对上述各指令用法进行简单梳理。

（本文中，**imm表示立即数，reg表示通用寄存器，mem表示存储器操作数，dest和src分别为目的操作数和源操作数**。如本文有错误或任何纰漏，敬请斧正，万分感谢！）

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

[TOC]

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### 一、数据传送类指令

​	数据传送类指令除**标志寄存器传送指令**外，**均不会影响标志位**。

#### 	1.通用数据传送指令

##### 	（1）传送指令MOV

```assembly
mov des,src         ;此处将src的值传送给dest，常见的操作类型如下：
mov reg/mem,imm	    ;立即数送寄存器或主存
mov reg/mem/seg,reg ;寄存器送寄存器(包括段寄存器)或主存
mov reg/seg,mem	    ;主存送寄存器(包括段寄存器)
mov reg/mem,seg     ;段寄存器送主存或寄存器
```

补充：1、MASM规定：十六进制数如果是以字母开头，则需要添加**前导0**。

​		   2、在传送时为了区别是字传送还是字节传送，可用汇编操作符**byte ptr (字节)**和**word ptr(字)**指定。

​		   3、8086中，**立即数不允许传至段寄存器**。

​		   4、8086指令系统没有**主存至主存**的数据传送，但可以通过**寄存器**间接实现。

​		   5、**段寄存器之间**不能直接进行数据传送。

​		   6、虽然存在寄存器和存储单元向CS传送数据的指令，但**不允许执行**。

##### （2）交换指令XCHG

```assembly
xchg reg,reg/mem ;操作数可以是字、字节
			    ;对换通用寄存器<->通用寄存器、通用寄存器<->存储器数据
			    ;不能在存储器与存储器之间交换数据
```

#### 2.堆栈操作指令

​	堆栈位于堆栈段中，采用SS记录段基地址。栈顶是**地址较小**的一段，用堆栈指针寄存器SP指示。

##### （1）进栈指令PUSH

​	进栈指令先使**SP减2**，然后把一个字操作数存入栈顶。堆栈操作的对象**只能是字操作数**，进栈时，**低字节存于低地址，高字节存于高地址**。

```assembly
push r16/m16/seg ;  sp-=2,ss:[sp] = r16/m16/seg
```

##### （2）出栈指令POP

​	出栈指令把栈顶的一个字送至目的操作数，然后**SP加2**。弹出时，**低地址字节送低字节，高地址字节送高字节**。

```assembly
pop r16/m16/seg  ;  r16/m16/seg = ss:[sp],sp+=2
```

#### 3.地址传送指令

##### （1）有效地址传送指令LEA

​	LEA指令将存储器操作数的**有效地址**传送至指定寄存器。

```assembly
lea r16,mem ; r16 = mem的有效地址ea
```

​	**注意：有效地址不是物理地址，也不是该单元的内容！！**

### 二、算术运算类指令

​	首先，我们需要了解部分有关**状态标志**的内容：

> **进位标志CF（Carry Flag）**：进位标志是针对<u>无符号整数运算</u>设计的，反映无符号数据加减运算结果是否超出范围、是否需要利用借（进）位反映正确结果。加减运算后，如果数据运算过程中出现了借位或进位，则CF=1；否则CF=0。
>
> **溢出标志OF（Overflow Flag）**：溢出标志是针对<u>有符号整数运算</u>设计的，反映有符号数据加减运算结果是否超出范围。
>
> **CF在超出范围后，加上进位或借位的运算结果仍正确，但OF超出范围后运算结果不正确。**
>
> **零标志ZF（Zero Flag）**：反映运算结果是否为0。
>
> **符号标志SF（Sign Flag）**：反映运算结果是正数还是负数。
>
> **奇偶标志PF（Parity Flag）**：反映运算结果最低字节中1的个数为奇数还是偶数。
>
> 调整标志AF（Adjust Flag）：反映加减运算时最低半字节有无进位或借位。

​	**加减运算结果将同时影响前五个标志。**

#### 1.加法指令

##### （1）加法指令ADD

​	加法指令ADD将源操作数与目的操作数相加，结果送到目的操作数。

```assembly
add reg,imm/reg/mem ; reg = reg + imm/reg/mem
add mem,imm/reg     ; mem = mem + imm/reg 
```

##### （2）带进位加法指令ADC

​	ADC指令除完成ADD加法运算外，**还要加进位CF**，主要用于与ADD结合实现多精度数相加。

```assembly
add reg,imm/reg/mem ; reg = reg + imm/reg/mem + CF
add mem,imm/reg     ; mem = mem + imm/reg + CF
```

##### （3）增量指令INC

​	INC指令对操作数加1（增量）。

```assembly
inc reg/mem ; reg/mem -= 1
```

#### 2.减法指令

##### （1）减法指令SUB

​	减法指令SUB使目的操作数减去源操作数，结果送目的操作数。

```assembly
sub reg,imm/reg/mem   ; reg = reg - imm/reg/mem
sub mem,imm/reg       ; mem = mem - imm/reg 
```

##### （2）带借位减法指令SBB

​	带借位减法指令SBB将目的操作数减去源操作数，**还要减去借（进）位CF**，结果送目的操作数。

```assembly
sbb reg,imm/reg/mem   ; reg = reg - imm/reg/mem - CF
sbb mem,imm/reg       ; mem = mem - imm/reg - CF
```

##### （3）减量指令DEC

​	DEC指令对操作数减1（减量）。

```assembly
dec reg/mem ; reg/mem += 1
```

##### （4）求补指令NEG

​	NEG指令对操作数执行求补运算，将操作数**按位取反后加1**（或表述为：**用0减去操作数，然后将结果返回操作数**）。

```assembly
neg reg/mem	; 将reg/mem按位取反后加1
```

##### （5）比较指令CMP

```assembly
cmp reg,imm/reg/mem ; reg - imm/reg/mem
cmp mem,imm/reg	    ; mem - imm/reg
```

​	CMP指令与SUB指令执行同样的操作，**同样影响标志，但不会影响目的操作数**。所以，后面常跟**条件转移指令**，产生不同的分支。

#### 3.乘法指令

​	乘法指令用来实现两个二进制数的相乘运算，包括两条指令：**无符号数乘法指令MUL与有符号数乘法指令IMUL**。

```assembly
mul r8/m8   ; 无符号字节乘，ax = al * r8/m8
mul r16/m16 ; 无符号字乘，dx.ax = ax * r16/m16
imul r8/m8  ; 有符号字节乘，ax = al * r8/m8
imul r16/m16; 有符号字乘，dx.ax = ax * r16/m16
```

​	乘法指令隐含使用操作数**AX和DX**，若是字节量相乘，则其得到的16位字存入AX；若是16位数据相乘，则其得到的32为结果，**高字节存入DX，低字节存入AX**。

​	乘法指令利用对OF、CF的影响，可以判断**相乘的结果中高一半是否含有有效数值**。如果高一半没有有效数值，即对MUL指令高一半为0，对IMUL指令高一半是低一半的符号扩展，则OF=CF=0，否则OF=CF=1。

​	乘法指令对其他状态标志的影响**没有定义**。

#### 4.除法指令

​	除法指令用来实现两个二进制数的相除运算，包括两条指令：**无符号数除法指令DIV与有符号数除法指令IDIV**。

```assembly
div r8/m8   ; 无符号字节除，al = ax ÷ r8/m8的商，ah = ax ÷ r8/m8的余数
div r16/m16 ; 无符号字除，ax = dx.ax ÷ r16/m16的商，dx = dx.ax ÷ r16/m16的余数
idiv r8/m8  ; 有符号字节除，al = ax ÷ r8/m8的商，ah = ax ÷ r8/m8的余数
idiv r16/m16; 有符号字除，ax = dx.ax ÷ r16/m16的商，dx = dx.ax ÷ r16/m16的余数
```

​	如果是字节除法，AX除以r8/m8，8位商存入AL，8位余数存入AH；如果是字除法，DX.AX除以r16/m16，16位商存入AX，16位余数存入DX。**余数的符号与被除数相同。**

​	如果除数为0，或者产生的结果超出了表达范围，则会产生**除法溢出**。

### 三、位操作类指令

#### 1.逻辑运算指令

​	双操作数逻辑运算指令AND、OR、XOR、TEST指令支持的操作数**和加减法指令一样**，且均设置**CF=OF=0**，并**根据结果设置SF、ZF、PF**，而对AF无定义。

##### （1）逻辑与指令AND

```assembly
and dest,src
```

##### （2）逻辑或指令OR

```assembly
or dest,src
```

##### （3）逻辑异或指令XOR

```assembly
xor dest,src
```

##### （4）逻辑非指令NOT

```assembly
not reg/mem
```

##### （5）测试指令TEST

```assembly
test dest,src
```

​	TEST操作数对两操作数执行**按位逻辑与运算**，但结果不回到目的操作数，**只根据结果来设置状态标志**，这条指令之后一般是条件转移指令，用于测试条件转向不同的程序段。

#### 2.移位指令

​	移位指令分为**逻辑移位指令和算术移位指令**，分别有**左移和右移**操作。

```assembly
shl reg/mem,1/cl ; 逻辑左移，reg/mem左移1/cl位，最低位补0，最高位进入CF
shr reg/mem,1/cl ; 逻辑右移，reg/mem右移1/cl位，最高位补0，最低位进入CF
sal reg/mem,1/cl ; 算术左移，功能与shl相同
sar reg/mem,1/cl ; 算术右移，reg/mem右移1/cl位，最高位不变，最低位进入CF
			    ; 移位位数大于一时，用CL寄存器的值表示
```

​	移位指令按照移位后的结果影响SF、ZF、PF，对AF没有定义。如果进行1位移动，根据**最高符号位是否改变**设置OF：如果移位前后最高位有变化，则OF=1，否则OF=0；**如果移位数大于1，则OF不确定**。

​	SHL移位1次，相当于无符号数乘2；SAL移位1次，相当于有符号数乘2；SHR移位1次，相当于无符号数除以2，商在目的操作数中，余数由CF反映；SAR移位1次，相当于有符号数除以2，**当操作数位负且最低位有1移出时，结果会与与之等效的IDIV指令结果不同**。

#### 3.循环移位指令

​	循环移位指令类似移位指令，不过要将**从一端移出的位返回到另一端**形成循环。

```assembly
rol reg/mem,1/cl ;不带进位循环左移
ror reg/mem,1/cl ;不带进位循环右移
rcl reg/mem,1/cl ;带进位循环左移
rcr reg/mem,1/cl ;带进位循环右移
```

​	后两条指令**将CF也纳入循环位**中，与操作数一起构成的9位或17位二进制数一起进行移位。循环移位指令按照功能设置进位CF，不影响SF、PF、ZF、AF标志，对OF影响与移位指令一样。

### 四、控制转移类指令

#### 1.无条件转移指令

​	无条件转移是无任何先决条件就能使程序改变执行顺序。JMP指令可以将程序转移到**1MB**的任何位置，根据跳转距离，可以将转移分为**段内转移和段间转移**。

​	段内转移是指在当前代码段**64KB**内转移（不需要改变CS，只改变IP）。如果转移范围可以用一个8位数表达，则为**“短转移”**；如果需要用16位数表达，则为**“长转移”**。

​	段间转移是指当前代码段跳转到另一个代码段，因此需要改变CS段地址和IP偏移地址，称为**“远转移”**。转移目标地址必须用**32位**数表达。

##### （1）段内转移，相对寻址

``` assembly
jmp label ; ip = ip + 偏移量
```

​	通常，汇编程序会根据位移量大小**自动生成短转移或近转移指令**。同时，汇编程序也提供 **near ptr** 转移操作符。

##### （2）段内转移，间接寻址

```assembly
jmp r16/m16 ; ip = r16/m16
```

​	注：该指令不会修改CS内容，只会修改IP内容。

##### （3）段间转移，直接寻址

```assembly
jmp far ptr label ; ip = label的偏移地址，cs = label的段地址
```

​	一个标号是否在同一个段内汇编程序能够自己识别。如果要强制远转移，则可以使用伪指令 far ptr 。

##### （4）段间转移，间接寻址

```assembly
jmp far ptr mem ; ip = [mem] , cs = [mem+2]
```

​	段间间接转移用一个双字存储单元表示目的地址。其中，**低字位送IP寄存器，高字位送CS寄存器**。

#### 2.条件转移指令

​	JCC根据指定条件确定是否发生转移。如果满足条件，则转移至目标地址执行程序，否则将顺序执行下一条指令。JCC跳转**只能使用段内相对短跳转**。该指令不影响标志，但需要利用标志。

```assembly
jcc label ; 条件满足，发生偏移 ip += 8位位移量，否则，ip += 2
```

​	附：常见标志判断的条件：

> ### 1、判断单个标志的状态
>
> #### （1）JZ/JE和JNZ/JNE利用零标志ZF，判断结果是否为零或相等。
>
> #### （2）JS和JNS利用符号标志SF，判断结果是正是负。
>
> #### （3）JO和JNO利用溢出标志OF，判断结果是否产生溢出。
>
> #### （4）JP/JPE和JNP/JPO利用奇偶标志PF，判断结果中的“1”个数是偶数还是奇数。
>
> #### （5）JC/JB/JNAE和JNC/JNB/JAE利用进位标志CF，判断结果是否进位或借位。
>
> ### 2、用于比较无符号数的高低
>
> #### 	无符号数高低由CF确定，相等由ZF确定。低于、不低于、不高于、高于分别对应JB(JNAE)、JNB(JAE)、JBE(JNA)、JNBE(JA)。
>
> ### 3、用于比较有符号数的大小
>
> #### 	比较有符号数大小需要组合OF、SF、ZF标志。小于、不小于、不大于、大于分别对应JL(JNGE)、JNL(JGE)、JLE(JNG)、JNLE(JG)。

#### 3.循环指令

​	循环流程的条件一般是循环计数，在程序中用循环计数来控制循环次数。

```assembly
jcxz label          ; cx=0则转移，否则顺序执行
loop label          ; cx=cx-1;若cx!=0，则循环:ip=ip+位移量，否则顺序执行
loopz/loope label   ; cx=cx-1;若cx!=0且zf=1，则循环:ip=ip+位移量，否则顺序执行
loopnz/loopne label ; cx=cx-1;若cx!=0且zf=0，则循环:ip=ip+位移量，否则顺序执行
```

​	循环指令不影响标志。其操作数label采用相对寻址方式，表示循环的目标地址是一个8位位移量。

​	使用LOOP指令实现循环有三个要点：**在CX中放置循环次数，LOOP指令的标号一般应在前面，要执行的循环程序段应该写在标号和LOOP指令之前**。

#### 4.子程序指令

​	子程序由主程序执行子程序调用指令CALL来调用；而子程序执行完后用子程序返回指令RET返回主程序继续执行。

##### （1）子程序调用指令CALL

​	类似无条件转移JMP指令，子程序调用指令CALL可以分为**段内调用和段间调用**；同时，CALL目标地址也可以采用**相对寻址、直接寻址、间接寻址方式**。其中，保护CS:IP的方法时压入堆栈，获取CS:IP的方法则是弹出堆栈。

```assembly
call label         ; 段内调用，相对寻址：sp=sp-2,ss:[sp]=ip,ip=ip+16位偏移量
call r16/m16       ; 段内调用，间接寻址：sp=sp-2,ss:[sp]=ip,ip=r16/m16
call far ptr label ; 段间调用，直接寻址：sp=sp-2,ss:[sp]=cs,sp=sp-2,ss:[sp]=ip,ip=label偏移地址,cs=label段地址
call far ptr mem   ; 段间调用，间接寻址：sp=sp-2,ss:[sp]=cs,sp=sp-2,ss:[sp]=ip,ip=[mem],cs=[mem+2]
```

##### （2）子程序返回指令RET

​	子程序执行完后，应返回主程序继续执行，该功能由RET指令完成。

```assembly
ret     ; 无参数段内返回：ip=ss:[sp],sp=sp+2
ret i16 ; 有参数段内返回：ip=ss:[sp],sp=sp+2,sp=sp+i16
ret     ; 无参数段间返回：ip=ss:[sp],sp=sp+2,cs=ss:[sp],sp=sp+2
ret i16 ; 有参数段间返回：ip=ss:[sp],sp=sp+2,cs=ss:[sp],sp=sp+2,sp=sp+i16
```

#### 5.中断指令

```assembly
int i8 ; 中断调用指令：产生i8号中断
iret   ; 中断返回指令：实现中断返回
into   ; 溢出中断指令：of=1则产生4号中断，否则顺序执行
```

